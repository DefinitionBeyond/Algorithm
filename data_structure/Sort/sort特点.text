冒泡排序：BubbleSort
      未改进的时候：O(n^2)，每一趟只选取一个最大或最小的数放在最后
       改进：标记一些不必进行再比的数
        适用情况分析：
        稳定
        大部分采取顺序，链式也可实现
        空间复杂度O(1)
        时间复杂度O(n^2)
        数据顺序对算法影响不大

选择排序：SelectSort
        O(n^2)
        适用情况分析：
        不稳定
         数组，链表均可实现
        空间复杂度：O(1)
        时间复杂度：O(n^2)
        最坏情况：O(n^2) 第一个元素为最大元素，其余元素正序，需要交换n-1个元素（如：4 3 2 1）
        最好情况：O(n^2) 正序，不需要交换元素
        选择排序的最坏情况和最好情况下的实际没有太大区别。即选择排序对于原始记录的顺序不敏感。

插入排序：InsertSort
     适用情况分析：
     稳定
     数组，链表均可实现
     空间复杂度O(1)
     时间复杂度O(n^2)
     最差情况：反序，需要移动n*(n-1)/2个元素
     最好情况：正序，不需要移动元素
     数据量较小，较有序的情况下性能较好

归并排序：MergingSort
       使用情况分析：
       稳定
       链式实现
       空间复杂度：O(n)
       时间复杂度：O(nlogn)
       最坏情况：O(nlogn)
       最好情况：O(nlogn)


快排：quickSort
         适用情况分析：
         不稳定。
         顺序实现
         空间复杂度：O(1)
         时间复杂度：O(nlogn)
         最坏情况：O(n2)要排序数组基本有序，基准值每次取最大（最小）元素，退化为冒泡。
         最好情况：O(nlog2n) 基准值两边元素个数基本相同.


希尔排序：ShellSort
        适用情况分析：
        不稳定
        采取顺序实现，对下标敏感
        空间复杂度O(1)
        时间复杂度O(nlogn)
        步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。
         Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1
         已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,...)

堆排序：HeapSort
        使用情况分析：
        不稳定
        顺序结构实现
        时间复杂度：o(nlogn)
        空间复杂度：o(1)
        由于建初始堆所需的比较次数较多，不建议在数据量小的情况下使用

基数排序：radixSort
        使用情况分析：
        稳定
        链式实现
        时间复杂度：假设在基数排序中，r为基数，d为位数。则基数排序的时间复杂度为O(d(n+r))
        空间复杂度：在基数排序过程中，对于任何位数上的基数进行“装桶”操作时，都需要n+r个临时空间
        数据量大时有明显优势，通常使用LSD法

